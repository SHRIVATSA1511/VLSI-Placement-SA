# Chip Floor-planning Optimization with Simulated Annealing
This repository presents a Python-based implementation of the Simulated Annealing optimization algorithm applied to the classic chip floor-planning problem. The project aims to find an optimal, non-overlapping placement of electronic modules on a chip die by minimizing a combined cost function of wirelength and overlap penalties.

## Theoretical Background
Chip floor-planning is a combinatorial optimization problem where the goal is to arrange a set of rectangular modules on a given area. 

The primary objective:

1.Wirelength between connected modules (nets) is minimized.<br/>
2.Overlaps between modules are avoided (or heavily penalized).<br/>
3.The placement fits within the chip boundary.

Finding an optimal solution is computationally expensive due to the vast number of possible arrangements.

# Simulated Annealing
Simulated annealing is an optimization technique that searches solution space for the global minimum through random sampling. It explores the solution space by accepting both better-cost and, with a certain probability, worse-cost solutions to avoid getting stuck in a local minimum. The probability of accepting a worse solution decreases as the simulation "cools," allowing the algorithm to converge on a high-quality global solution.

## Implementation
The core of this implementation is the simulated annealing algorithm, which operates on the following key components:

State Representation: The current placement of all modules is stored in a dictionary, mapping each module's identifier to its coordinates on the chip.

Cost Function: A function cost(placement) calculates the total energy of the system. This energy is defined as:

Wirelength: The sum of the Manhattan distances between the centers of all connected modules.

Overlap Penalty: A large value added for each pair of modules that overlap.

Neighbor Method: A new state is generated by randomly selecting one module and moving it to a new random position within the chip boundaries.

Metropolis Condition: A new state is accepted based on the Metropolis criterion. If the new cost is lower, it's always accepted. If it's higher, it's accepted with a probability governed by the Boltzmann factor, exp(Î”E / T), where Î”E is the change in energy and T is the current temperature.

Cooling Schedule: The temperature T is reduced at each iteration by a constant cooling coefficient, gradually decreasing the likelihood of accepting a worse solution.

ðŸš€ How to Run the Code
Clone the repository:

git clone https://github.com/your-username/your-repository-name.git
cd your-repository-name

Install dependencies:
This project requires matplotlib for visualizing the final results.

pip install matplotlib

Run the Python script:

python simulated_annealing.py

The script will print the final cost and placement coordinates to the console and display a plot of the optimized chip layout.

ðŸ“ˆ Example Output
Below is an example of a potential output generated by the script, showing a successful, non-overlapping placement with a low cost.

âœ¨ Future Work
This project can be extended to model more complex, real-world scenarios:

Advanced Cost Functions: Incorporate additional factors such as thermal hotspots, signal integrity, and timing constraints.

Alternative Neighborhood Functions: Explore different move operators, such as module swapping or rotation, to improve exploration of the solution space.

Hybrid Optimization Techniques: Integrate this simulated annealing algorithm into a larger hybrid framework, such as a genetic algorithm, to accelerate convergence and improve solution quality.

Interactive Visualization: Develop a GUI to allow real-time control over simulation parameters and dynamic visualization of the annealing process.
