# Chip Floor-planning Optimization with Simulated Annealing
This repository presents a Python-based implementation of the Simulated Annealing optimization algorithm applied to the classic chip floor-planning problem. The project aims to find an optimal, non-overlapping placement of electronic modules on a chip die by minimizing a combined cost function of wirelength and overlap penalties.

## Theoretical Background
Chip floor-planning is a combinatorial optimization problem where the goal is to arrange a set of rectangular modules on a given area. 

The primary objective:

1.Wirelength between connected modules (nets) is minimized.<br/>
2.Overlaps between modules are avoided (or heavily penalized).<br/>
3.The placement fits within the chip boundary.

Finding an optimal solution is computationally expensive due to the vast number of possible arrangements.

# Simulated Annealing
Simulated annealing is an optimization technique that searches solution space for the global minimum through random sampling. It explores the solution space by accepting both better-cost and, with a certain probability, worse-cost solutions to avoid getting stuck in a local minimum. The probability of accepting a worse solution decreases as the simulation "cools," allowing the algorithm to converge on a high-quality global solution.

# Implementation
This project approaches the chip floor-planning problem as a combinatorial optimization task. At its core, the method balances two competing objectives: keeping modules physically separated while minimizing the wiring distance between them.

Instead of exhaustively evaluating every possible arrangement—which becomes computationally infeasible as the number of modules grows—we rely on Simulated Annealing (SA), a search method inspired by thermodynamics.

## Key aspects of the methodology:
### Objective Function:
The cost function evaluates the quality of a layout by summing:</b>
1.The total wirelength of all interconnections.</b>
2.A penalty score proportional to the number of overlaps.

### Exploration of the Solution Space:
Neighborhoods are generated by relocating a single module at random. This ensures small, controlled changes that gradually explore better layouts.

### Acceptance of New Solutions:
The algorithm occasionally accepts worse layouts to avoid premature convergence. The likelihood of such acceptance decreases as the system “cools,” echoing the process of annealing metals.
